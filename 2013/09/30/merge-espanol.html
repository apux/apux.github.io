<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>El Blog de ApuX - Merge (Español)</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="main" role="main">
      <nav>
  <ul>
    <li>
<a class="blog-title" href="/">        El Blog de Ap<span>uX</span>
</a>      <span class="caption">My Learning about Software Development</span>
    </li>
  </ul>
</nav>

      <section id="content">
          <article>
    <h1 class="heading">
      Merge (Español)
      <time>Sep 30 2013</time>
    </h1>
    <p>Hay una funcionalidad de Rails que yo utilizo bastante pero tengo la impresión
de que no es tan difundida como debería. Estoy hablando del metodo <code>merge</code> de
<code>ActiveRecord</code>. Posiblemente la razón por la que no es muy utilizado es que
existe un metodo con el mismo nombre en la clase <code>Hash</code> y eso provoca cierta
confusion.</p>

<h2>El <code>merge</code> de <code>Hash</code></h2>

<p>El metodo <code>merge</code> de <code>Hash</code> mezcla dos <em>hashes</em> y devuelve el resultado en un
tercer <em>hash</em>. Ejemplo:</p>
<pre class="highlight ruby"><code><span class="n">h1</span> <span class="o">=</span> <span class="p">{</span><span class="ss">a: </span><span class="s1">'cat'</span><span class="p">,</span> <span class="ss">b: </span><span class="s1">'dog'</span><span class="p">}</span>
<span class="n">h2</span> <span class="o">=</span> <span class="p">{</span><span class="ss">c: </span><span class="s1">'bird'</span><span class="p">}</span>
<span class="n">h3</span> <span class="o">=</span> <span class="n">h1</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">h2</span><span class="p">)</span>
<span class="c1"># =&gt; {:a=&gt;"cat", :b=&gt;"dog", :c=&gt;"bird"}</span>
</code></pre>

<p>Este método está disponible en el
<a href="http://www.ruby-doc.org/core-2.0.0/Hash.html#method-i-merge">Core de Ruby</a>.</p>

<h2>El <code>merge</code> de <code>ActiveRecord</code></h2>

<p>El metodo <code>merge</code> de <code>ActiveRecord</code>, en cambio, sirve para construir consultas
que involucren dos o más modelos que necesiten de trabajar con <em>scopes</em> ya
definidos.</p>

<p>Por ejemplo: imaginemos los modelos <code>Client</code> y <code>Product</code>, con <em>scopes</em> definidos
la siguiente manera:</p>
<pre class="highlight ruby"><code><span class="c1"># app/models/client.rb</span>
<span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:products</span>

  <span class="n">scope</span> <span class="ss">:recently_activated</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s1">'activated_at &gt; ?'</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">month</span><span class="p">.</span><span class="nf">ago</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1"># app/models/product.rb</span>
<span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:client</span>

  <span class="n">scope</span> <span class="ss">:expensive</span><span class="p">,</span>  <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s1">'products.price &gt; 1000'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:small</span><span class="p">,</span>      <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s1">'products.size &lt;= 99'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:medium</span><span class="p">,</span>     <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s1">'products.size &gt; 99 AND products.size &lt; 999'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:big</span><span class="p">,</span>        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s1">'products.size &gt;= 999'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:available</span><span class="p">,</span>  <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">available: </span><span class="kp">true</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<p>Ahora, si quieremos conocer todos los clientes recientemente activados que hayan
comprado productos dispoibles, de talla mediana, y caros, se podría construir la
consulta de esta manera.</p>
<pre class="highlight ruby"><code><span class="no">Client</span><span class="p">.</span><span class="nf">recently_activated</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:products</span><span class="p">).</span>
  <span class="nf">where</span><span class="p">(</span><span class="s1">'products.price &gt; 1000 AND products.size &gt; 99 AND products.size &lt; 999 AND products.available = ?'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
</code></pre>

<p>O, usando el método <code>merge</code>:</p>
<pre class="highlight ruby"><code><span class="no">Client</span><span class="p">.</span><span class="nf">recently_activated</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:products</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Product</span><span class="p">.</span><span class="nf">expensive</span><span class="p">.</span><span class="nf">medium</span><span class="p">.</span><span class="nf">available</span><span class="p">)</span>
</code></pre>

<p>El último fragmento de código no es sólo más fácil de construir y más fácil de
leer, además sigue mejor el concepto DRY. Si, por alguna razón, la definición de
&lsquo;medium&rsquo; cambia, sólo se tiene que cambiar en un único lugar, todas las
consultas se mantienen intactas.</p>

<p>Además, es posible usar <code>merge</code> dentro de un <em>scope</em>. Ejemplo:</p>
<pre class="highlight ruby"><code><span class="c1"># app/models/client.rb</span>
<span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:products</span>

  <span class="n">scope</span> <span class="ss">:recently_activated</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s1">'activated_at &gt; ?'</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">month</span><span class="p">.</span><span class="nf">ago</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:with_expensive_products</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">:products</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Product</span><span class="p">.</span><span class="nf">expensive</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<p>Bastante útil, ¿cierto?</p>

  </article>
  <div id="disqus_thread"></div>
<script type="text/javascript">
//<![CDATA[
                  var disqus_shortname = 'elblogdeapux';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


      </section>
      <footer>
  <div class="container">
    <ul class="large-column">
      <li><h5 class="heading">Recent Articles</h5></li>
      <li>
        <ol>
            <li>
              <a href="/2015/08/31/how-to-install-postgresql-in-chakra-linux.html">How to Install Postgresql in Chakra Linux</a>
              <span>Aug 31</span>
            </li>
            <li>
              <a href="/2015/07/20/using-vim-regexp-to-update-to-rspec3-syntax.html">Using Vim Regexp to Update to RSpec 3 Syntax</a>
              <span>Jul 20</span>
            </li>
            <li>
              <a href="/2015/05/04/directory-tree.html">Directory tree</a>
              <span>May  4</span>
            </li>
            <li>
              <a href="/2015/04/13/directory-structure-conventions-in-rspec-and-minitest.html">Directory structure conventions in RSpec and Minitest</a>
              <span>Apr 13</span>
            </li>
            <li>
              <a href="/2015/01/12/joins-vs-includes-espanol.html">Joins vs Includes (Español)</a>
              <span>Jan 12</span>
            </li>
            <li>
              <a href="/2014/12/08/joins-vs-includes.html">Joins vs Includes</a>
              <span>Dec  8</span>
            </li>
            <li>
              <a href="/2014/09/01/minitest-v4-y-v5.html">Minitest v4 y  v5</a>
              <span>Sep  1</span>
            </li>
            <li>
              <a href="/2014/07/14/minitest-v4-and-v5.html">Minitest v4 and v5</a>
              <span>Jul 14</span>
            </li>
            <li>
              <a href="/2014/03/11/formularios-anidados.html">Formularios anidados</a>
              <span>Mar 11</span>
            </li>
            <li>
              <a href="/2014/02/10/como-solucionar-las-consultas-n-1-en-rails.html">Cómo solucionar consultas N+1 en Rails</a>
              <span>Feb 10</span>
            </li>
        </ol>
      </li>
    </ul>

    <ul class="small-column">
      <li><h5 class="heading">Tags</h5></li>
      <li>
        <ol>
            <li><a href="/tags/rails.html">Rails (8)</a></li>
            <li><a href="/tags/activerecord.html">ActiveRecord (7)</a></li>
            <li><a href="/tags/nested_attributes.html">nested_attributes (1)</a></li>
            <li><a href="/tags/formularios.html">formularios (1)</a></li>
            <li><a href="/tags/ruby.html">Ruby (5)</a></li>
            <li><a href="/tags/struct.html">Struct (1)</a></li>
            <li><a href="/tags/openstruct.html">OpenStruct (1)</a></li>
            <li><a href="/tags/asociaciones.html">Asociaciones (1)</a></li>
            <li><a href="/tags/minitest.html">Minitest (3)</a></li>
            <li><a href="/tags/postgresql.html">postgresql (1)</a></li>
            <li><a href="/tags/chakra.html">chakra (1)</a></li>
            <li><a href="/tags/vim.html">vim (1)</a></li>
            <li><a href="/tags/regexp.html">regexp (1)</a></li>
            <li><a href="/tags/rspec.html">rspec (1)</a></li>
            <li><a href="/tags/rspec.html">RSpec (2)</a></li>
            <li><a href="/tags/tree.html">tree (1)</a></li>
        </ol>
      </li>
      <ul>
  </div>
</footer>

    </div>
  </body>
</html>
