<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>El Blog de ApuX - Using Vim Regexp to Update to RSpec 3 Syntax</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="main" role="main">
      <nav>
  <ul>
    <li>
<a class="blog-title" href="/">        El Blog de Ap<span>uX</span>
</a>      <span class="caption">My Learning about Software Development</span>
    </li>
  </ul>
</nav>

      <section id="content">
          <article>
    <h1 class="heading">
      Using Vim Regexp to Update to RSpec 3 Syntax
      <time>Jul 20 2015</time>
    </h1>
    <p>Recently, I had to update a project that uses RSpec. Part of the migration consisted in updating the RSpec syntax from version 2 to version 3. Since I use Vim, I ended up creating a bunch of regular expressions to make those updates. Here I will show you how I created them (and what I learned doing it).</p>

<p>The main change is RSpec 3 is not monkey-patching objects any more, and because of that it is not possible to use sentences like this:</p>
<pre class="highlight ruby"><code><span class="no">FizzBuzz</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">value</span><span class="p">.</span><span class="nf">should</span> <span class="o">==</span> <span class="s2">"1"</span>
</code></pre>

<p>The new way to do it in RSpec 3 is:</p>
<pre class="highlight ruby"><code><span class="n">expect</span><span class="p">(</span><span class="no">FizzBuzz</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">value</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="s2">"1"</span>
</code></pre>

<p>And that is the change we need to do with our regular expressions.</p>

<p>Vim&rsquo;s regular expressions are a little different from Ruby&rsquo;s one because we will need to escape more characters in order to have it working.</p>

<p>In Ruby, a regexp that finds a <code>.should</code> could be:</p>
<pre class="highlight plaintext"><code>/\.should/
</code></pre>

<p>For example:</p>
<pre class="highlight ruby"><code><span class="s2">"value.should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/\.should/</span>
<span class="c1"># =&gt; #&lt;MatchData ".should"&gt;</span>
</code></pre>

<p>By escaping the dot <code>\.</code> we ensure that it matches an actual dot <code>.</code>, otherwise, it will match any character because the dot actually means that in regular expressions: any character.</p>

<p>Example with unescaped dot:</p>
<pre class="highlight ruby"><code><span class="s2">"value.should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/.should/</span>
<span class="c1"># =&gt; #&lt;MatchData ".should"&gt;</span>

<span class="s2">"value_should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/.should/</span>
<span class="c1"># =&gt; #&lt;MatchData "_should"&gt;</span>
</code></pre>

<p>Example with escaped dot:</p>
<pre class="highlight ruby"><code><span class="s2">"value.should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/\.should/</span>
<span class="c1"># =&gt; #&lt;MatchData ".should"&gt;</span>

<span class="s2">"value_should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/\.should/</span>
<span class="c1"># =&gt; nil</span>
</code></pre>

<p>This is the behaviour we are looking for.</p>

<p>It also works the same way in Vim. If we search this pattern in Vim, it will find a line that contains <code>.should</code>.</p>

<p>We can try it in Vim&rsquo;s search mode.</p>
<pre class="highlight plaintext"><code>/\.should
</code></pre>

<p>It works as expected. Great!</p>

<h2>Capture group</h2>

<p>Now, we want to capture the string (the group of characters) that precedes <code>.should</code>. We can do this in Ruby:</p>
<pre class="highlight plaintext"><code>/(.+)\.should/
</code></pre>

<p>Te plus sign <code>+</code> indicates one or more repetitions of the previous character. In this case the previous character is <em>any character</em>, since we did not escape de dot <code>.</code> this time because it is the behaviour we are looking for. It will match any string that contains <code>.should</code> and it will capture all the characters behind it.</p>

<p>Let&rsquo;s see how it works.</p>
<pre class="highlight ruby"><code><span class="s2">"value.should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/.+\.should/</span>
<span class="c1"># =&gt; #&lt;MatchData "value.should" 1:"value"&gt;</span>
</code></pre>

<p>You can see it matched and, additionally, it contains the string we captured (<code>1:&quot;value&quot;</code>).</p>

<p>But if we try to use it in Vim it will not work. We need to escape both parenthesis <code>(</code> and <code>)</code>, and the plus sign <code>+</code>.</p>
<pre class="highlight plaintext"><code>/\(.\+\)\.should/
</code></pre>

<p>Now it will match in Vim.</p>

<p>In Ruby, it is possible to use the captured string with the special global variable <code>$1</code>. Example:</p>
<pre class="highlight ruby"><code><span class="s2">"value.should == 1"</span><span class="p">.</span><span class="nf">match</span> <span class="sr">/(.+)\.should/</span>
<span class="vg">$1</span>
<span class="c1"># =&gt; "value"</span>
</code></pre>

<p>In Vim, this value is stored in <code>\1</code> and we can use it while replacing. Example:</p>
<pre class="highlight plaintext"><code>:%s/\(.\+\)\.should/expect(\1).to/g
</code></pre>

<p>And it worked! It changed all the lines containing <code>.should</code> .</p>

<p>There was only one problem, if the line is indented (and chances are it is), our replace command will include the blank spaces inside the parenthesis.</p>
<pre class="highlight ruby"><code><span class="n">expect</span><span class="p">(</span>      <span class="n">value</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="s2">"1"</span><span class="p">)</span>
</code></pre>

<p>To avoid it, we need to improve our regexp. Let&rsquo;s do that by capturing all the blank spaces at the beginning of the line, and adding them to the new string. We can use <code>^</code> to indicate the beginning of a line in both Ruby and Vim, and it is not necessary to escape it.</p>
<pre class="highlight plaintext"><code>:%s/^\( \+\)\(.\+\)\.should/\1expect(\2).to/g
</code></pre>

<p>Since a new captured pattern was introduced before the one we previously had, the numbering were also altered and now the blank spaces are stored in <code>\1</code> and the following string in <code>\2</code>.</p>

<h2>Variants</h2>

<p>The regexp we just build is too generic for our requirements. Specifically, it ignores that the matchers have to change too.</p>

<p>RSpec 3 does not support some matchers that version 2 did. For example, <code>==</code>, and <code>=~</code>, <code>be_true</code> needs to be changed to <code>be_truthy</code>, etcetera.</p>

<p>So, I prefer to run specific replacements for each one. These are what I used.</p>
<pre class="highlight plaintext"><code>:%s/^\( \+\)\(.\+\)\.should be_true/\1expect(\2).to be_truthy/g
:%s/^\( \+\)\(.\+\)\.should be_false/\1expect(\2).to be_falsey/g
:%s/^\( \+\)\(.\+\)\.should == nil/\1expect(\2).to be_nil/g
:%s/^\( \+\)\(.\+\)\.should ==/\1expect(\2).to eq/g
:%s/^\( \+\)\(.\+\)\.should =\~/\1expect(\2).to match/g
:%s/^\( \+\)\(.\+\)\.should_not ==/\1expect(\2).not_to eq/g
:%s/^\( \+\)\(.\+\)\.should/\1expect(\2).to/g
</code></pre>

<p>Executing these commands in this order does most of the work.</p>

<p>The first 3 commands change the expectations about booleans and nil. The forth one changes the <code>==</code> matcher to <code>eq</code>. Then we change the <code>=~</code> (for regexp) to <code>match</code> (note that we had to escape the <code>~</code>). The following command replaces the <code>should_not</code> with <code>==</code> to <code>not_to eq</code>, and, finally, we use the generic replace to change everything else (this will match remaining expectations like <code>render.should redirect_to(path)</code>).</p>

<h2>stub</h2>

<p>Stubbing syntax was also modified in this version.</p>

<p>In RSpec 2, this was the syntax.</p>
<pre class="highlight ruby"><code><span class="n">my_object</span><span class="p">.</span><span class="nf">stub</span><span class="p">(</span><span class="ss">:my_method</span><span class="p">).</span><span class="nf">and_return</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>

<p>In RSpec 3, this is the new syntax.</p>
<pre class="highlight ruby"><code><span class="n">allow</span><span class="p">(</span><span class="n">my_object</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:my_method</span><span class="p">).</span><span class="nf">and_return</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>

<p>So, we need to capture the indentation spaces and the object. It could be done with this:</p>
<pre class="highlight plaintext"><code>:%s/^\( \+\)\(.\+\)\.stub/\1allow(\2).to receive/g
</code></pre>

<p>But again, it is too generic, because we can have <code>any_instance.stub</code> and <code>.stub_chain</code> and these lines will match too, but, obviously, it will not be changed correctly. In that case, it is preferable to replace them first and execute our replacements in this order.</p>
<pre class="highlight plaintext"><code>:%s/^\( \+\)\(.\+\)\.any_instance.stub/\1allow_any_instance_of(\2).to receive/g
:%s/^\( \+\)\(.\+\)\.stub_chain/\1allow(\2).to receive_message_chain/g
:%s/^\( \+\)\(.\+\)\.stub/\1allow(\2).to receive/g
</code></pre>

<p>Now we have it. In my case, I had no more special cases to attend, but if you have, I hope this explanation could help you to build your own commands for replacing.</p>

<p>Any corrections or suggestions are welcome.</p>

  </article>
  <div id="disqus_thread"></div>
<script type="text/javascript">
//<![CDATA[
                  var disqus_shortname = 'elblogdeapux';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


      </section>
      <footer>
  <div class="container">
    <ul class="large-column">
      <li><h5 class="heading">Recent Articles</h5></li>
      <li>
        <ol>
            <li>
              <a href="/2015/08/31/how-to-install-postgresql-in-chakra-linux.html">How to Install Postgresql in Chakra Linux</a>
              <span>Aug 31</span>
            </li>
            <li>
              <a href="/2015/07/20/using-vim-regexp-to-update-to-rspec3-syntax.html">Using Vim Regexp to Update to RSpec 3 Syntax</a>
              <span>Jul 20</span>
            </li>
            <li>
              <a href="/2015/05/04/directory-tree.html">Directory tree</a>
              <span>May  4</span>
            </li>
            <li>
              <a href="/2015/04/13/directory-structure-conventions-in-rspec-and-minitest.html">Directory structure conventions in RSpec and Minitest</a>
              <span>Apr 13</span>
            </li>
            <li>
              <a href="/2015/01/12/joins-vs-includes-espanol.html">Joins vs Includes (Español)</a>
              <span>Jan 12</span>
            </li>
            <li>
              <a href="/2014/12/08/joins-vs-includes.html">Joins vs Includes</a>
              <span>Dec  8</span>
            </li>
            <li>
              <a href="/2014/09/01/minitest-v4-y-v5.html">Minitest v4 y  v5</a>
              <span>Sep  1</span>
            </li>
            <li>
              <a href="/2014/07/14/minitest-v4-and-v5.html">Minitest v4 and v5</a>
              <span>Jul 14</span>
            </li>
            <li>
              <a href="/2014/03/11/formularios-anidados.html">Formularios anidados</a>
              <span>Mar 11</span>
            </li>
            <li>
              <a href="/2014/02/10/como-solucionar-las-consultas-n-1-en-rails.html">Cómo solucionar consultas N+1 en Rails</a>
              <span>Feb 10</span>
            </li>
        </ol>
      </li>
    </ul>

    <ul class="small-column">
      <li><h5 class="heading">Tags</h5></li>
      <li>
        <ol>
            <li><a href="/tags/rails.html">Rails (8)</a></li>
            <li><a href="/tags/activerecord.html">ActiveRecord (7)</a></li>
            <li><a href="/tags/nested_attributes.html">nested_attributes (1)</a></li>
            <li><a href="/tags/formularios.html">formularios (1)</a></li>
            <li><a href="/tags/ruby.html">Ruby (5)</a></li>
            <li><a href="/tags/struct.html">Struct (1)</a></li>
            <li><a href="/tags/openstruct.html">OpenStruct (1)</a></li>
            <li><a href="/tags/asociaciones.html">Asociaciones (1)</a></li>
            <li><a href="/tags/minitest.html">Minitest (3)</a></li>
            <li><a href="/tags/postgresql.html">postgresql (1)</a></li>
            <li><a href="/tags/chakra.html">chakra (1)</a></li>
            <li><a href="/tags/vim.html">vim (1)</a></li>
            <li><a href="/tags/regexp.html">regexp (1)</a></li>
            <li><a href="/tags/rspec.html">rspec (1)</a></li>
            <li><a href="/tags/rspec.html">RSpec (2)</a></li>
            <li><a href="/tags/tree.html">tree (1)</a></li>
        </ol>
      </li>
      <ul>
  </div>
</footer>

    </div>
  </body>
</html>
